/* This file is generated. Do not edit!
   see https://github.com/hpvb/dynload-wrapper (patched) for details
   generated by scripts/generate-wrapper.py 0.5
   flags: scripts/generate-wrapper.py --include include/wayland-egl.h --include include/wayland-egl-core.h --sys-include wayland_client-so_wrap.h --sys-include <wayland-egl.h> --sys-include <wayland-egl-core.h> --soname libwayland-egl.so.1 --init-name wayland_egl --output-header include_gen/wayland_egl-so_wrap.h --output-implementation src_gen/wayland_egl-so_wrap.c --ignore-other --include-dir include
*/
#include <stdint.h>

#define wl_egl_window_create wl_egl_window_create_dylibloader_orig_wayland_egl
#define wl_egl_window_destroy wl_egl_window_destroy_dylibloader_orig_wayland_egl
#define wl_egl_window_resize wl_egl_window_resize_dylibloader_orig_wayland_egl
#define wl_egl_window_get_attached_size wl_egl_window_get_attached_size_dylibloader_orig_wayland_egl
#include "wayland_client-so_wrap.h"
#include <wayland-egl.h>
#include <wayland-egl-core.h>
#undef wl_egl_window_create
#undef wl_egl_window_destroy
#undef wl_egl_window_resize
#undef wl_egl_window_get_attached_size
#include <dlfcn.h>
#include <stdio.h>
struct wl_egl_window *(*wl_egl_window_create_dylibloader_wrapper_wayland_egl)(struct wl_surface *, int, int);
void (*wl_egl_window_destroy_dylibloader_wrapper_wayland_egl)(struct wl_egl_window *);
void (*wl_egl_window_resize_dylibloader_wrapper_wayland_egl)(struct wl_egl_window *, int, int, int, int);
void (*wl_egl_window_get_attached_size_dylibloader_wrapper_wayland_egl)(struct wl_egl_window *, int *, int *);
int initialize_wayland_egl(int verbose) {
  void *handle;
  char *error;
  handle = dlopen("libwayland-egl.so.1", RTLD_LAZY);
  if (!handle) {
    if (verbose) {
      fprintf(stderr, "%s\n", dlerror());
    }
    return(1);
  }
  dlerror();
/* wl_egl_window_create */
  *(void **) (&wl_egl_window_create_dylibloader_wrapper_wayland_egl) = dlsym(handle, "wl_egl_window_create");
  if (verbose) {
    error = dlerror();
    if (error != NULL) {
      fprintf(stderr, "%s\n", error);
      return(1);
    }
  }
/* wl_egl_window_destroy */
  *(void **) (&wl_egl_window_destroy_dylibloader_wrapper_wayland_egl) = dlsym(handle, "wl_egl_window_destroy");
  if (verbose) {
    error = dlerror();
    if (error != NULL) {
      fprintf(stderr, "%s\n", error);
      return(1);
    }
  }
/* wl_egl_window_resize */
  *(void **) (&wl_egl_window_resize_dylibloader_wrapper_wayland_egl) = dlsym(handle, "wl_egl_window_resize");
  if (verbose) {
    error = dlerror();
    if (error != NULL) {
      fprintf(stderr, "%s\n", error);
      return(1);
    }
  }
/* wl_egl_window_get_attached_size */
  *(void **) (&wl_egl_window_get_attached_size_dylibloader_wrapper_wayland_egl) = dlsym(handle, "wl_egl_window_get_attached_size");
  if (verbose) {
    error = dlerror();
    if (error != NULL) {
      fprintf(stderr, "%s\n", error);
      return(1);
    }
  }
return 0;
}
